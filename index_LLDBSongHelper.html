/**
 * ----------------------------------------------------------------------
 * App Module: Song Helper
 * ----------------------------------------------------------------------
 * LLDB Song Helper ã‚¢ãƒ—ãƒªå‘ã‘ã®ãƒ‡ãƒ¼ã‚¿ãƒ­ã‚¸ãƒƒã‚¯
 * Based on aikotoba Backend v0.4.3
 */

const App_SongHelper = {

  // ======================================================================
  // 1. Request Feature (Current Version) - æ–°æ©Ÿèƒ½ã¯ãã®ã¾ã¾ç¶­æŒ
  // ======================================================================

  postRequest: function(query) {
    const lock = LockService.getScriptLock();
    if (lock.tryLock(10000)) {
      try {
        if (!query) return { status: 'error', message: 'å†…å®¹ãŒç©ºã§ã™' };
        
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        let sheet = ss.getSheetByName('SongHelper_ãƒªã‚¯ã‚¨ã‚¹ãƒˆ');
        
        if (!sheet) {
          sheet = ss.insertSheet('SongHelper_ãƒªã‚¯ã‚¨ã‚¹ãƒˆ');
          sheet.appendRow(['å—ä»˜æ—¥æ™‚', 'æ²è¼‰ON/OFF', 'è³ªå•å†…å®¹', 'å›ç­”å†…å®¹']);
        }
        
        const now = new Date();
        sheet.appendRow([now, 0, query, ""]);
        SpreadsheetApp.flush();
        
        this._sendNotification(now, query);
        
        return { status: 'success', message: 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸ' };
      } catch (e) {
        return { status: 'error', message: e.toString() };
      } finally {
        lock.releaseLock();
      }
    } else {
      return { status: 'error', message: 'ã‚µãƒ¼ãƒãƒ¼æ··é›‘ä¸­' };
    }
  },

  getRequests: function() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('SongHelper_ãƒªã‚¯ã‚¨ã‚¹ãƒˆ');
    if (!sheet) return { status: 'success', data: [] };
    
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { status: 'success', data: [] };
    
    const data = sheet.getRange(2, 1, lastRow - 1, 4).getValues();
    const filtered = data.filter(row => row[1] == 1 || row[1] === true);
    
    const requests = filtered.map(row => ({
      date: App_Common.formatDate(row[0]),
      question: String(row[2]),
      answer: String(row[3])
    })).reverse();
    
    return { status: 'success', data: requests };
  },

  _sendNotification: function(now, query) {
    try {
      const adminEmail = "noki.dochibi@gmail.com";
      const subject = "ã€LLDBã€‘æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå±Šãã¾ã—ãŸ";
      const body = `æ—¥æ™‚: ${Utilities.formatDate(now, "JST", "yyyy/MM/dd HH:mm")} \nå†…å®¹: ${query}`;
      MailApp.sendEmail(adminEmail, subject, body);
    } catch(e) { console.warn("é€šçŸ¥é€ä¿¡å¤±æ•—"); }
  },


  // ======================================================================
  // 2. Shiritori Logic (Ported from v0.4.3) - æ—§ãƒ­ã‚¸ãƒƒã‚¯ + æ–°ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹
  // ======================================================================

  playShiritori: function(query) {
    if (!query) return { status: 'error', message: 'No query' };

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('æ¥½æ›²ãƒ‡ãƒ¼ã‚¿');
    if (!sheet) return { status: 'error', message: 'Sheet "æ¥½æ›²ãƒ‡ãƒ¼ã‚¿" not found' };

    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { status: 'success', mode: 'shiritori', result: 'unknown_song', message: 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒç©ºã£ã½ã¿ãŸã„...' };

    // é–‹å§‹åˆ—ã‚’11(Kåˆ—)ã«å¤‰æ›´ã€‚å–å¾—æ•°ã¯17åˆ—ã€‚
    const data = sheet.getRange(2, 11, lastRow - 1, 17).getValues();

    // --- 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›æ›²ã®ç‰¹å®š ---
    let userSong = null;
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      const songName = String(row[9]);
      const songKana = String(row[16]);
      
      if (songName === query || songKana === query) {
        userSong = { title: songName, kana: songKana };
        break;
      }
    }

    if (!userSong) {
      return {
        status: 'success',
        mode: 'shiritori',
        result: 'unknown_song',
        message: `ã€Œ${query}ã€ï¼ï¼Ÿæœªç™ºè¡¨æ›²ã‹ã‚‚...ğŸ¤”<br>æ­£å¼åç§°ã§æ•™ãˆã¦ã­ï¼`
      };
    }

    // --- 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è² ã‘åˆ¤å®š ---
    let userLastChar = this._getLastChar(userSong.kana);
    if (userLastChar === 'ã‚“') {
      return {
        status: 'success',
        mode: 'shiritori',
        result: 'user_lose',
        user_song: userSong,
        message: `ã‚ã‚ã£ï¼ã€Œ${userSong.title}ã€ã¯ã€Œã‚“ã€ã§çµ‚ã‚ã‚‹ã‚ˆï¼<br>ä¿ºã®å‹ã¡ğŸ˜`
      };
    }

    // --- 3. Botã®å›ç­”å€™è£œã‚’æ¢ã™ ---
    let botCandidates = [];
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      const targetTitle = String(row[9]);
      const targetKana = String(row[16]);

      if (targetTitle === userSong.title) continue;
      if (targetTitle.includes('(') || targetTitle.includes('ï¼ˆ')) continue;

      if (targetKana.startsWith(userLastChar)) {
        if (this._getLastChar(targetKana) !== 'ã‚“') {
          botCandidates.push({ title: targetTitle, kana: targetKana });
        }
      }
    }

    // --- 4. Botã®è² ã‘åˆ¤å®š (è¿”ã™æ›²ãŒãªã„) ---
    if (botCandidates.length === 0) {
      return {
        status: 'success',
        mode: 'shiritori',
        result: 'user_win',
        user_song: userSong,
        message: `ã€Œ${userSong.title}ã€...ï¼<br>ã€Œ${userLastChar}ã€ã‹ã‚‰å§‹ã¾ã‚‹æ›²ãŒæ€ã„ã¤ã‹ãªã„...<br>ãã¬ã¬...ï¼å›ã®å‹ã¡ã ğŸ˜`
      };
    }

    // --- 5. Botã®é¸æ›² (Smart Selection) ---
    let safeCandidates = [];
    let killerCandidates = [];

    botCandidates.forEach(botCand => {
      const botLastChar = this._getLastChar(botCand.kana);
      const hasNext = data.some(row => {
        const tTitle = String(row[9]);
        const tKana = String(row[16]);
        if (tTitle === botCand.title) return false;
        if (tTitle.includes('(') || tTitle.includes('ï¼ˆ')) return false;
        return tKana.startsWith(botLastChar);
      });

      if (hasNext) {
        safeCandidates.push(botCand);
      } else {
        killerCandidates.push(botCand);
      }
    });

    let selectedSong;
    let isKillerMove = false;

    if (safeCandidates.length > 0) {
      selectedSong = safeCandidates[Math.floor(Math.random() * safeCandidates.length)];
    } else {
      selectedSong = killerCandidates[Math.floor(Math.random() * killerCandidates.length)];
      isKillerMove = true;
    }

    const botLastChar = this._getLastChar(selectedSong.kana);

    if (isKillerMove) {
      return {
        status: 'success',
        mode: 'shiritori',
        result: 'user_lose',
        user_song: userSong,
        bot_song: selectedSong,
        message: `ã€Œ${userSong.title}ã€ã ã­ã€‚<br>ãã‚Œãªã‚‰...ã€Œ${selectedSong.title}ã€ï¼<br>...ãŠã£ã¨ã€ã€Œ${botLastChar}ã€ã‹ã‚‰å§‹ã¾ã‚‹æ›²ã¯ã‚‚ã†ãªã„ã¿ãŸã„ã€‚<br>ä¿ºã®å‹ã¡ã ã­ğŸ˜`
      };
    }

    // --- 6. ãƒ’ãƒ³ãƒˆç”Ÿæˆ ---
    let nextHints = [];
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      const targetTitle = String(row[9]);
      const targetKana = String(row[16]);
      
      if (targetTitle === selectedSong.title) continue;
      if (targetTitle.includes('(') || targetTitle.includes('ï¼ˆ')) continue;

      if (targetKana.startsWith(botLastChar)) {
        nextHints.push({ title: targetTitle, kana: targetKana });
      }
    }
    
    // â˜…è¿½åŠ : ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå›ç­”å¯èƒ½ãªå…¨å€™è£œï¼ˆãƒ’ãƒ³ãƒˆç”¨ï¼‰
    const allCandidates = nextHints.map(h => h.title);

    // å¾“æ¥é€šã‚Šã®å°‘æ•°ã®ãƒ’ãƒ³ãƒˆï¼ˆJSONã‚µã‚¤ã‚ºå‰Šæ¸›ã®ãŸã‚å¿…è¦ãªã‚‰æ®‹ã™ï¼‰
    nextHints = this._shuffleArray(nextHints).slice(0, 5);

    return {
      status: 'success',
      mode: 'shiritori',
      result: 'continue',
      user_song: userSong,
      bot_song: selectedSong,
      next_char: botLastChar,
      hints: nextHints,
      all_candidates: allCandidates, // ãƒ’ãƒ³ãƒˆç”¨å…¨ãƒ‡ãƒ¼ã‚¿
      message: `ã€Œ${userSong.title}ã€ã ã­ã€‚<br>ãã‚Œãªã‚‰...ã€Œ${selectedSong.title}ã€ï¼<br>æ¬¡ã¯ã€Œ${botLastChar}ã€ã‹ã‚‰å§‹ã¾ã‚‹æ›²ã ã‚ˆï¼`
    };
  },


  // ======================================================================
  // 3. Title DB Search (Ported from v0.4.3) - æ—§ãƒ­ã‚¸ãƒƒã‚¯ + æ–°ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹
  // ======================================================================

  searchTitleData: function(query) {
    if (!query) return { status: 'error', message: 'No query' };

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    // â˜…å¤‰æ›´ç‚¹: ã‚·ãƒ¼ãƒˆåã‚’ã€Œæ¥½æ›²ãƒ‡ãƒ¼ã‚¿ã€ã«å¤‰æ›´
    const sheet = ss.getSheetByName('æ¥½æ›²ãƒ‡ãƒ¼ã‚¿');
    if (!sheet) return { status: 'error', message: 'Sheet "æ¥½æ›²ãƒ‡ãƒ¼ã‚¿" not found' };

    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { status: 'success', songs: [], albums: [], query: query };

    // â˜…å¤‰æ›´ç‚¹: é–‹å§‹åˆ—ã‚’11(Kåˆ—)ã«å¤‰æ›´
    const data = sheet.getRange(2, 11, lastRow - 1, 17).getValues();
    const qLower = query.toLowerCase();
    
    let songMatches = [];
    let diskMatches = [];

    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      const albTitle = String(row[2]);
      const sglTitle = String(row[6]);
      const songName = String(row[9]);
      const songKana = String(row[16]);

      if (songName.toLowerCase().includes(qLower) || songKana.includes(qLower)) {
        songMatches.push(this._formatSongData(row));
        if (sglTitle && sglTitle !== 'æœªåéŒ²') diskMatches.push({ type: 'single', name: sglTitle, row: row });
        if (albTitle && albTitle !== 'æœªåéŒ²') diskMatches.push({ type: 'album', name: albTitle, row: row });
      }
      if (albTitle.toLowerCase().includes(qLower)) diskMatches.push({ type: 'album', name: albTitle, row: row });
      else if (sglTitle.toLowerCase().includes(qLower)) diskMatches.push({ type: 'single', name: sglTitle, row: row });
    }

    return {
      status: 'success',
      mode: 'title',
      query: query,
      songs: songMatches,
      albums: this._groupDisks(diskMatches, data)
    };
  },


  // ======================================================================
  // 4. Lyrics Search (Ported from v0.4.3) - æ—§ãƒ­ã‚¸ãƒƒã‚¯ç¶­æŒ
  // ======================================================================

  searchLyricsLegacy: function(query) {
    if (!query) return { status: 'error', message: 'No query' };

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName('æ­Œè©');
    if (!sheet) sheet = ss.getSheetByName('ã‚·ãƒ¼ãƒˆ1');
    if (!sheet) return { status: 'error', message: 'Lyrics Sheet not found' };

    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return { status: 'success', results: [], query: query, random_message: "" };

    const data = sheet.getRange(2, 1, lastRow - 1, 5).getValues();
    let results = [];
    
    const qLower = query.toLowerCase();
    const qNormalized = this._normalizeString(query);

    let fuzzyType = null;
    let actualQuery = null;

    // --- 1. å®Œå…¨ä¸€è‡´ãƒ»éƒ¨åˆ†ä¸€è‡´æ¤œç´¢ (ã‚ªãƒªã‚¸ãƒŠãƒ«) ---
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      let searchTarget = "";
      for (let j = 1; j < row.length; j++) {
        searchTarget += String(row[j]) + " ";
      }

      if (searchTarget.toLowerCase().includes(qLower)) {
        const title = row[0];
        let lyrics = this._getLongestString(row, 1);
        // â˜…ä¿®æ­£: ã‚³ãƒ”ãƒ¼æ™‚ã®ã‚¹ãƒšãƒ¼ã‚¹å‰Šé™¤ (ãƒ•ãƒ¬ãƒ¼ã‚ºï¼ˆæ›²åï¼‰)
        results.push({
          title: title,
          phrase: lyrics,
          display_text: `${lyrics}ï¼ˆ${title}ï¼‰`
        });
      }
    }

    // --- 2. æ­£è¦åŒ–æ¤œç´¢ (ã‚‚ã—ã‹ã—ã¦æ¤œç´¢) ---
    if (results.length === 0 && qNormalized.length > 0) {
      for (let i = 0; i < data.length; i++) {
        const row = data[i];
        let lyricsText = "";
        for (let j = 1; j < row.length; j++) { lyricsText += String(row[j]) + " "; }
        
        const lyricsNormalized = this._normalizeString(lyricsText);

        if (lyricsNormalized.includes(qNormalized)) {
          const title = row[0];
          let lyrics = this._getLongestString(row, 1);
          // â˜…ä¿®æ­£: ã‚³ãƒ”ãƒ¼æ™‚ã®ã‚¹ãƒšãƒ¼ã‚¹å‰Šé™¤
          results.push({
            title: title,
            phrase: lyrics,
            display_text: `${lyrics}ï¼ˆ${title}ï¼‰`
          });
          
          fuzzyType = "ã‚‚ã—ã‹ã—ã¦æ¤œç´¢";
          const matchIndex = lyricsNormalized.indexOf(qNormalized);
          if (matchIndex !== -1) {
              actualQuery = lyricsText.substring(matchIndex, matchIndex + qNormalized.length).trim();
          } else {
              actualQuery = qNormalized;
          }
          
          if (results.length >= 10) break;
        }
      }
    }

    // --- 3. ã‚ã„ã¾ã„æ¤œç´¢ (Fuzzy Search) ---
    if (results.length === 0 && query.length >= 2) {
      for (let i = 0; i < data.length; i++) {
        const row = data[i];
        let lyricsText = "";
        for (let j = 1; j < row.length; j++) { lyricsText += String(row[j]) + " "; }
        
        if (lyricsText.length > 0) {
          if (this._hasMostChars(query, lyricsText)) {
              const title = row[0];
              let lyrics = this._getLongestString(row, 1);
              
              // â˜…ä¿®æ­£: ã‚³ãƒ”ãƒ¼æ™‚ã®ã‚¹ãƒšãƒ¼ã‚¹å‰Šé™¤
              results.push({
                title: title,
                phrase: lyrics,
                display_text: `${lyrics}ï¼ˆ${title}ï¼‰`
              });
              fuzzyType = "ã‚ã„ã¾ã„æ¤œç´¢";
              actualQuery = "è¿‘ã„ãƒ•ãƒ¬ãƒ¼ã‚º";
              if (results.length >= 3) break;
          }
        }
      }
    }

    // --- ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ---
    let randomMsg = "";
    if (data.length > 0) {
      const randomRow = data[Math.floor(Math.random() * data.length)];
      const rawLyrics = randomRow[1];
      if (rawLyrics) {
        randomMsg = String(rawLyrics).replace(/\r?\n/g, ' ');
      }
    }

    return {
      status: 'success',
      mode: 'lyrics',
      results: results,
      query: query,
      random_message: randomMsg,
      fuzzy_type: fuzzyType,
      actual_query: actualQuery
    };
  },


  // ======================================================================
  // 5. Internal Helpers (Ported from v0.4.3 & Refactored)
  // ======================================================================

  _normalizeString: function(str) {
    if (!str) return "";
    let s = String(str);
    s = s.replace(/[ï¼¡-ï¼ºï½-ï½šï¼-ï¼™]/g, function(s) {
      return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
    });
    s = s.toLowerCase();
    s = s.replace(/[\u30a1-\u30f6]/g, function(match) {
      var chr = match.charCodeAt(0) - 0x60;
      return String.fromCharCode(chr);
    });
    return s;
  },

  _getLastChar: function(kana) {
    if (!kana) return '';
    kana = kana.trim();
    let last = kana.slice(-1);
    if (last === 'ãƒ¼' && kana.length > 1) {
      last = kana.slice(-2, -1);
    }
    const smallMap = { 'ã': 'ã‚', 'ãƒ': 'ã„', 'ã…': 'ã†', 'ã‡': 'ãˆ', 'ã‰': 'ãŠ', 'ã£': 'ã¤', 'ã‚ƒ': 'ã‚„', 'ã‚…': 'ã‚†', 'ã‚‡': 'ã‚ˆ', 'ã‚': 'ã‚' };
    if (smallMap[last]) {
      last = smallMap[last];
    }
    return last;
  },

  _shuffleArray: function(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  },

  _getLongestString: function(row, startIndex) {
    let longest = "";
    for (let j = startIndex; j < row.length; j++) {
      const str = String(row[j]);
      if (str.length > longest.length) {
        longest = str;
      }
    }
    return longest;
  },

  _hasMostChars: function(query, target) {
    let matchCount = 0;
    let targetArr = target.split('');
    for (let i = 0; i < query.length; i++) {
      const char = query[i];
      const idx = targetArr.indexOf(char);
      if (idx !== -1) {
        matchCount++;
        targetArr.splice(idx, 1);
      }
    }
    return (matchCount / query.length) >= 0.8;
  },

  _formatDuration: function(val) {
    if (!val) return 'ä¸æ˜';
    if (val instanceof Date) {
      return Utilities.formatDate(val, 'JST', 'm:ss');
    }
    return String(val);
  },
  
  _formatDate: function(val) {
    if (!val || val === 'æœªåéŒ²') return 'ä¸æ˜';
    if (val instanceof Date) {
      return Utilities.formatDate(val, 'JST', 'yyyy/MM/dd');
    }
    return String(val).substring(0, 10);
  },

  _calculateAikoAge: function(dateStr) {
    if (!dateStr || dateStr === 'æœªåéŒ²') return null;
    const birthDate = new Date(1975, 10, 22);
    const targetDate = new Date(dateStr);
    if (isNaN(targetDate.getTime())) return null;
    let age = targetDate.getFullYear() - birthDate.getFullYear();
    const m = targetDate.getMonth() - birthDate.getMonth();
    if (m < 0 || (m === 0 && targetDate.getDate() < birthDate.getDate())) age--;
    return age;
  },

  _groupDisks: function(matches, allData) {
    const uniqueDiskNames = [...new Set(matches.map(m => m.name))];
    let results = [];
    uniqueDiskNames.forEach(diskName => {
      // row[2]=Album, row[6]=Single
      const songsInDisk = allData.filter(row => String(row[2]) === diskName || String(row[6]) === diskName);
      if (songsInDisk.length === 0) return;
      const isAlbum = String(songsInDisk[0][2]) === diskName;
      const trackIdx = isAlbum ? 3 : 7;
      const dateIdx = isAlbum ? 4 : 8;
      songsInDisk.sort((a, b) => (Number(a[trackIdx]) || 99) - (Number(b[trackIdx]) || 99));
      results.push({
        disk_name: diskName,
        release_date: this._formatDate(songsInDisk[0][dateIdx]),
        songs: songsInDisk.map(row => ({ title: row[9], order: row[trackIdx] }))
      });
    });
    return results;
  },

  _formatSongData: function(row) {
    // row[8]=SingleReleaseDate, row[4]=AlbumReleaseDate
    let releaseDateStr = (row[8] !== 'æœªåéŒ²' && row[8] !== '') ? row[8] : row[4];
    let age = this._calculateAikoAge(releaseDateStr);
    
    // row[6]=SingleName, row[5]=SingleNo, row[7]=SingleTrackNo
    const sglInfo = (row[6] !== 'æœªåéŒ²' && row[6])
      ? `${this._formatDate(row[8])} ç™ºå£²ã® ${row[5]} æšç›®ã®ã‚·ãƒ³ã‚°ãƒ«ã€${row[6]}ã€ã® ${row[7]} æ›²ç›®ã«åéŒ²ã•ã‚Œã¦ã„ã‚‹ã‚ˆã€‚`
      : null;
      
    // row[2]=AlbumName, row[1]=AlbumNo, row[3]=AlbumTrackNo
    const albInfo = (row[2] !== 'æœªåéŒ²' && row[2])
      ? `${this._formatDate(row[4])} ç™ºå£²ã® ${row[1]} æšç›®ã®ã‚¢ãƒ«ãƒãƒ ã€${row[2]}ã€ã® ${row[3]} æ›²ç›®ã«åéŒ²ã•ã‚Œã¦ã„ã‚‹ã‚ˆã€‚`
      : null;
      
    // row[14]=MVUrl, row[15]=LiveUrl
    const linkUrl = (row[14] && row[14] !== 'æœªåéŒ²') ? row[14] : row[15];
  
    return {
      title: String(row[9]),
      reading: String(row[16]),
      single_info: sglInfo,
      album_info: albInfo,
      arranger: row[10],
      duration: this._formatDuration(row[11]),
      bpm: row[12],
      age_at_release: age,
      link_url: linkUrl
    };
  }
};
